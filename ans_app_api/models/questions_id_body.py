# coding: utf-8

"""
    API V2

    #### Authorization The API can only be accessed by creating a token at: [https://ans.app/users/tokens](https://ans.app/users/tokens).<br> The provided token is a Bearer token and needs to be set in the Request Header with key Authorization and value \"Bearer [token]\" for every request.<br>  #### Pagination The API generates several headers due to its use of pagination, this includes:      - Link, the standard link header defined in RFC 8288     - Current-Page, which shows the current page of the requested data     - Page-Items, which shows the amount of items per page     - Total-Pages, which shows the total amount of pages available     - Total-Count, which shows the total count of objects that was requested  #### Rate Limits The API enforces a rate limit of 500 request per minute per ip-address. If the rate limit is exceeded, the API responds with a HTTP 429 Too Many Requests response code.<br> You can use the following response headers to confirm the current rate limit and monitor the number of requests remaining in the current minute.<br>      - RateLimit-Limit, the current limit for your account     - RateLimit-Remaining, the number of remaining requests in the current minute     - RateLimit-Reset, the number of seconds until the limit is reset  #### Search The API offers search functionality through GET requests with a query. For all search endpoints see the [Search](#/Search) section.<br>      - The query must consist of the attribute and the search value connected with a colon (:) or a greater than (>) or smaller than (<) sign.     - You can use the greater and smaller than symbols for numeric and date values.     - If your search value contains whitespaces, you must quote your search query with single or double quotes.     - You can also combine searches by using a whitespace to separate the attributes.     - If your search value is equal to \"null\", all records with null values for that attribute will be found.     - We perform case sensitive exact match searches only.     - You can search for multiple values, by adding square brackets around the search parameters and seperating the parameters using commas without spaces.     - You can see some example queries in the documented search endpoints.   #### Webhooks The API offers you the ability to listen to specific events that occur within the application. For example, you can use webhooks to:      - Archive results when an assignment is archived     - Add users after an assignment is created     - Export a result after it has been approved  When creating a webhook you can specify which events you want to listen to. You can listen to all events, all events for a specific object or only one event for an object.<br> You can listen to 'create', 'update' and 'destroy' events on an object or a combination for example:      - '*' - all events for all objects     - 'assignment' - All events for an assignment     - 'assignment.update' - Only notify when an assignment is updated  The webhooks API returns a secret after creating a new webhook. This secret can be used to verify that the webhook call comes from Ans by creating a sha256 HMAC with the request body and this secret and comparing it to the X-Ans-Signature Header.<br>  Webhook requests are automatically retried up to five times if the endpoint returns certain HTTP response codes. The time interval between retries is gradually extended. Every webhook event is logged and contains the response code, headers and body of the response for debugging purposes.<br>  The following objects are currently supported:      - Assignment     - Result     - User   # noqa: E501

    OpenAPI spec version: v2
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class QuestionsIdBody(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'bonus': 'bool',
        'category': 'OneOfquestionsIdBodyCategory',
        'choice_type': 'OneOfquestionsIdBodyChoiceType',
        'layout': 'OneOfquestionsIdBodyLayout',
        'content': 'str',
        'fill_content': 'str',
        'feedback_correct': 'str',
        'feedback_incorrect': 'str',
        'feedback_mistake': 'str',
        'grading_description': 'str',
        'grading_type': 'OneOfquestionsIdBodyGradingType',
        'max_bound': 'bool',
        'new_page': 'bool',
        'partial_scoring': 'bool',
        'points': 'str',
        'predefined_answer': 'str',
        'skippable': 'bool',
        'stack_vertically': 'bool',
        'start_with_zero': 'bool',
        'word_limit': 'int',
        'zero_bound': 'bool',
        'objective_ids': 'list[int]'
    }

    attribute_map = {
        'bonus': 'bonus',
        'category': 'category',
        'choice_type': 'choice_type',
        'layout': 'layout',
        'content': 'content',
        'fill_content': 'fill_content',
        'feedback_correct': 'feedback_correct',
        'feedback_incorrect': 'feedback_incorrect',
        'feedback_mistake': 'feedback_mistake',
        'grading_description': 'grading_description',
        'grading_type': 'grading_type',
        'max_bound': 'max_bound',
        'new_page': 'new_page',
        'partial_scoring': 'partial_scoring',
        'points': 'points',
        'predefined_answer': 'predefined_answer',
        'skippable': 'skippable',
        'stack_vertically': 'stack_vertically',
        'start_with_zero': 'start_with_zero',
        'word_limit': 'word_limit',
        'zero_bound': 'zero_bound',
        'objective_ids': 'objective_ids'
    }

    def __init__(self, bonus=False, category=None, choice_type=None, layout=None, content=None, fill_content=None, feedback_correct=None, feedback_incorrect=None, feedback_mistake=None, grading_description=None, grading_type=None, max_bound=True, new_page=False, partial_scoring=True, points=None, predefined_answer=None, skippable=False, stack_vertically=False, start_with_zero=True, word_limit=0, zero_bound=True, objective_ids=None):  # noqa: E501
        """QuestionsIdBody - a model defined in Swagger"""  # noqa: E501
        self._bonus = None
        self._category = None
        self._choice_type = None
        self._layout = None
        self._content = None
        self._fill_content = None
        self._feedback_correct = None
        self._feedback_incorrect = None
        self._feedback_mistake = None
        self._grading_description = None
        self._grading_type = None
        self._max_bound = None
        self._new_page = None
        self._partial_scoring = None
        self._points = None
        self._predefined_answer = None
        self._skippable = None
        self._stack_vertically = None
        self._start_with_zero = None
        self._word_limit = None
        self._zero_bound = None
        self._objective_ids = None
        self.discriminator = None
        if bonus is not None:
            self.bonus = bonus
        if category is not None:
            self.category = category
        if choice_type is not None:
            self.choice_type = choice_type
        if layout is not None:
            self.layout = layout
        self.content = content
        if fill_content is not None:
            self.fill_content = fill_content
        if feedback_correct is not None:
            self.feedback_correct = feedback_correct
        if feedback_incorrect is not None:
            self.feedback_incorrect = feedback_incorrect
        if feedback_mistake is not None:
            self.feedback_mistake = feedback_mistake
        if grading_description is not None:
            self.grading_description = grading_description
        if grading_type is not None:
            self.grading_type = grading_type
        if max_bound is not None:
            self.max_bound = max_bound
        if new_page is not None:
            self.new_page = new_page
        if partial_scoring is not None:
            self.partial_scoring = partial_scoring
        if points is not None:
            self.points = points
        if predefined_answer is not None:
            self.predefined_answer = predefined_answer
        if skippable is not None:
            self.skippable = skippable
        if stack_vertically is not None:
            self.stack_vertically = stack_vertically
        if start_with_zero is not None:
            self.start_with_zero = start_with_zero
        if word_limit is not None:
            self.word_limit = word_limit
        if zero_bound is not None:
            self.zero_bound = zero_bound
        if objective_ids is not None:
            self.objective_ids = objective_ids

    @property
    def bonus(self):
        """Gets the bonus of this QuestionsIdBody.  # noqa: E501

        Defines if the question is a bonus question  # noqa: E501

        :return: The bonus of this QuestionsIdBody.  # noqa: E501
        :rtype: bool
        """
        return self._bonus

    @bonus.setter
    def bonus(self, bonus):
        """Sets the bonus of this QuestionsIdBody.

        Defines if the question is a bonus question  # noqa: E501

        :param bonus: The bonus of this QuestionsIdBody.  # noqa: E501
        :type: bool
        """

        self._bonus = bonus

    @property
    def category(self):
        """Gets the category of this QuestionsIdBody.  # noqa: E501


        :return: The category of this QuestionsIdBody.  # noqa: E501
        :rtype: OneOfquestionsIdBodyCategory
        """
        return self._category

    @category.setter
    def category(self, category):
        """Sets the category of this QuestionsIdBody.


        :param category: The category of this QuestionsIdBody.  # noqa: E501
        :type: OneOfquestionsIdBodyCategory
        """

        self._category = category

    @property
    def choice_type(self):
        """Gets the choice_type of this QuestionsIdBody.  # noqa: E501


        :return: The choice_type of this QuestionsIdBody.  # noqa: E501
        :rtype: OneOfquestionsIdBodyChoiceType
        """
        return self._choice_type

    @choice_type.setter
    def choice_type(self, choice_type):
        """Sets the choice_type of this QuestionsIdBody.


        :param choice_type: The choice_type of this QuestionsIdBody.  # noqa: E501
        :type: OneOfquestionsIdBodyChoiceType
        """

        self._choice_type = choice_type

    @property
    def layout(self):
        """Gets the layout of this QuestionsIdBody.  # noqa: E501


        :return: The layout of this QuestionsIdBody.  # noqa: E501
        :rtype: OneOfquestionsIdBodyLayout
        """
        return self._layout

    @layout.setter
    def layout(self, layout):
        """Sets the layout of this QuestionsIdBody.


        :param layout: The layout of this QuestionsIdBody.  # noqa: E501
        :type: OneOfquestionsIdBodyLayout
        """

        self._layout = layout

    @property
    def content(self):
        """Gets the content of this QuestionsIdBody.  # noqa: E501

        The content of the question  # noqa: E501

        :return: The content of this QuestionsIdBody.  # noqa: E501
        :rtype: str
        """
        return self._content

    @content.setter
    def content(self, content):
        """Sets the content of this QuestionsIdBody.

        The content of the question  # noqa: E501

        :param content: The content of this QuestionsIdBody.  # noqa: E501
        :type: str
        """
        if content is None:
            raise ValueError("Invalid value for `content`, must not be `None`")  # noqa: E501

        self._content = content

    @property
    def fill_content(self):
        """Gets the fill_content of this QuestionsIdBody.  # noqa: E501

        The content for a fill in the blanks question with a gap  # noqa: E501

        :return: The fill_content of this QuestionsIdBody.  # noqa: E501
        :rtype: str
        """
        return self._fill_content

    @fill_content.setter
    def fill_content(self, fill_content):
        """Sets the fill_content of this QuestionsIdBody.

        The content for a fill in the blanks question with a gap  # noqa: E501

        :param fill_content: The fill_content of this QuestionsIdBody.  # noqa: E501
        :type: str
        """

        self._fill_content = fill_content

    @property
    def feedback_correct(self):
        """Gets the feedback_correct of this QuestionsIdBody.  # noqa: E501

        The feedback displayed if the question is correct  # noqa: E501

        :return: The feedback_correct of this QuestionsIdBody.  # noqa: E501
        :rtype: str
        """
        return self._feedback_correct

    @feedback_correct.setter
    def feedback_correct(self, feedback_correct):
        """Sets the feedback_correct of this QuestionsIdBody.

        The feedback displayed if the question is correct  # noqa: E501

        :param feedback_correct: The feedback_correct of this QuestionsIdBody.  # noqa: E501
        :type: str
        """

        self._feedback_correct = feedback_correct

    @property
    def feedback_incorrect(self):
        """Gets the feedback_incorrect of this QuestionsIdBody.  # noqa: E501

        The feedback displayed if the question is completely incorrect  # noqa: E501

        :return: The feedback_incorrect of this QuestionsIdBody.  # noqa: E501
        :rtype: str
        """
        return self._feedback_incorrect

    @feedback_incorrect.setter
    def feedback_incorrect(self, feedback_incorrect):
        """Sets the feedback_incorrect of this QuestionsIdBody.

        The feedback displayed if the question is completely incorrect  # noqa: E501

        :param feedback_incorrect: The feedback_incorrect of this QuestionsIdBody.  # noqa: E501
        :type: str
        """

        self._feedback_incorrect = feedback_incorrect

    @property
    def feedback_mistake(self):
        """Gets the feedback_mistake of this QuestionsIdBody.  # noqa: E501

        The feedback displayed if the question is partially correct  # noqa: E501

        :return: The feedback_mistake of this QuestionsIdBody.  # noqa: E501
        :rtype: str
        """
        return self._feedback_mistake

    @feedback_mistake.setter
    def feedback_mistake(self, feedback_mistake):
        """Sets the feedback_mistake of this QuestionsIdBody.

        The feedback displayed if the question is partially correct  # noqa: E501

        :param feedback_mistake: The feedback_mistake of this QuestionsIdBody.  # noqa: E501
        :type: str
        """

        self._feedback_mistake = feedback_mistake

    @property
    def grading_description(self):
        """Gets the grading_description of this QuestionsIdBody.  # noqa: E501

        A description displayed when grading the question  # noqa: E501

        :return: The grading_description of this QuestionsIdBody.  # noqa: E501
        :rtype: str
        """
        return self._grading_description

    @grading_description.setter
    def grading_description(self, grading_description):
        """Sets the grading_description of this QuestionsIdBody.

        A description displayed when grading the question  # noqa: E501

        :param grading_description: The grading_description of this QuestionsIdBody.  # noqa: E501
        :type: str
        """

        self._grading_description = grading_description

    @property
    def grading_type(self):
        """Gets the grading_type of this QuestionsIdBody.  # noqa: E501


        :return: The grading_type of this QuestionsIdBody.  # noqa: E501
        :rtype: OneOfquestionsIdBodyGradingType
        """
        return self._grading_type

    @grading_type.setter
    def grading_type(self, grading_type):
        """Sets the grading_type of this QuestionsIdBody.


        :param grading_type: The grading_type of this QuestionsIdBody.  # noqa: E501
        :type: OneOfquestionsIdBodyGradingType
        """

        self._grading_type = grading_type

    @property
    def max_bound(self):
        """Gets the max_bound of this QuestionsIdBody.  # noqa: E501

        Indicates if the student’s score is limited to the amount of question points  # noqa: E501

        :return: The max_bound of this QuestionsIdBody.  # noqa: E501
        :rtype: bool
        """
        return self._max_bound

    @max_bound.setter
    def max_bound(self, max_bound):
        """Sets the max_bound of this QuestionsIdBody.

        Indicates if the student’s score is limited to the amount of question points  # noqa: E501

        :param max_bound: The max_bound of this QuestionsIdBody.  # noqa: E501
        :type: bool
        """

        self._max_bound = max_bound

    @property
    def new_page(self):
        """Gets the new_page of this QuestionsIdBody.  # noqa: E501

        Defines whether the question will start on a new page (handwritten tests only)  # noqa: E501

        :return: The new_page of this QuestionsIdBody.  # noqa: E501
        :rtype: bool
        """
        return self._new_page

    @new_page.setter
    def new_page(self, new_page):
        """Sets the new_page of this QuestionsIdBody.

        Defines whether the question will start on a new page (handwritten tests only)  # noqa: E501

        :param new_page: The new_page of this QuestionsIdBody.  # noqa: E501
        :type: bool
        """

        self._new_page = new_page

    @property
    def partial_scoring(self):
        """Gets the partial_scoring of this QuestionsIdBody.  # noqa: E501

        Defines whether a student can receive partial scores on this question  # noqa: E501

        :return: The partial_scoring of this QuestionsIdBody.  # noqa: E501
        :rtype: bool
        """
        return self._partial_scoring

    @partial_scoring.setter
    def partial_scoring(self, partial_scoring):
        """Sets the partial_scoring of this QuestionsIdBody.

        Defines whether a student can receive partial scores on this question  # noqa: E501

        :param partial_scoring: The partial_scoring of this QuestionsIdBody.  # noqa: E501
        :type: bool
        """

        self._partial_scoring = partial_scoring

    @property
    def points(self):
        """Gets the points of this QuestionsIdBody.  # noqa: E501

        Defines the number of points allocated to this question  # noqa: E501

        :return: The points of this QuestionsIdBody.  # noqa: E501
        :rtype: str
        """
        return self._points

    @points.setter
    def points(self, points):
        """Sets the points of this QuestionsIdBody.

        Defines the number of points allocated to this question  # noqa: E501

        :param points: The points of this QuestionsIdBody.  # noqa: E501
        :type: str
        """

        self._points = points

    @property
    def predefined_answer(self):
        """Gets the predefined_answer of this QuestionsIdBody.  # noqa: E501

        Defines the question's predefined answer (digital test only for question types open and code)  # noqa: E501

        :return: The predefined_answer of this QuestionsIdBody.  # noqa: E501
        :rtype: str
        """
        return self._predefined_answer

    @predefined_answer.setter
    def predefined_answer(self, predefined_answer):
        """Sets the predefined_answer of this QuestionsIdBody.

        Defines the question's predefined answer (digital test only for question types open and code)  # noqa: E501

        :param predefined_answer: The predefined_answer of this QuestionsIdBody.  # noqa: E501
        :type: str
        """

        self._predefined_answer = predefined_answer

    @property
    def skippable(self):
        """Gets the skippable of this QuestionsIdBody.  # noqa: E501

        Indicates that this question can be skipped by students who have the right to skip questions  # noqa: E501

        :return: The skippable of this QuestionsIdBody.  # noqa: E501
        :rtype: bool
        """
        return self._skippable

    @skippable.setter
    def skippable(self, skippable):
        """Sets the skippable of this QuestionsIdBody.

        Indicates that this question can be skipped by students who have the right to skip questions  # noqa: E501

        :param skippable: The skippable of this QuestionsIdBody.  # noqa: E501
        :type: bool
        """

        self._skippable = skippable

    @property
    def stack_vertically(self):
        """Gets the stack_vertically of this QuestionsIdBody.  # noqa: E501

        Forces the question's multiple choice options to be stacked vertically  # noqa: E501

        :return: The stack_vertically of this QuestionsIdBody.  # noqa: E501
        :rtype: bool
        """
        return self._stack_vertically

    @stack_vertically.setter
    def stack_vertically(self, stack_vertically):
        """Sets the stack_vertically of this QuestionsIdBody.

        Forces the question's multiple choice options to be stacked vertically  # noqa: E501

        :param stack_vertically: The stack_vertically of this QuestionsIdBody.  # noqa: E501
        :type: bool
        """

        self._stack_vertically = stack_vertically

    @property
    def start_with_zero(self):
        """Gets the start_with_zero of this QuestionsIdBody.  # noqa: E501

        The marking of the question will always start at zero points  # noqa: E501

        :return: The start_with_zero of this QuestionsIdBody.  # noqa: E501
        :rtype: bool
        """
        return self._start_with_zero

    @start_with_zero.setter
    def start_with_zero(self, start_with_zero):
        """Sets the start_with_zero of this QuestionsIdBody.

        The marking of the question will always start at zero points  # noqa: E501

        :param start_with_zero: The start_with_zero of this QuestionsIdBody.  # noqa: E501
        :type: bool
        """

        self._start_with_zero = start_with_zero

    @property
    def word_limit(self):
        """Gets the word_limit of this QuestionsIdBody.  # noqa: E501

        Defines the question's word limit. If this value is 0, then the question has no word limit  # noqa: E501

        :return: The word_limit of this QuestionsIdBody.  # noqa: E501
        :rtype: int
        """
        return self._word_limit

    @word_limit.setter
    def word_limit(self, word_limit):
        """Sets the word_limit of this QuestionsIdBody.

        Defines the question's word limit. If this value is 0, then the question has no word limit  # noqa: E501

        :param word_limit: The word_limit of this QuestionsIdBody.  # noqa: E501
        :type: int
        """

        self._word_limit = word_limit

    @property
    def zero_bound(self):
        """Gets the zero_bound of this QuestionsIdBody.  # noqa: E501

        Indicates if the student's score cannot be lower than zero  # noqa: E501

        :return: The zero_bound of this QuestionsIdBody.  # noqa: E501
        :rtype: bool
        """
        return self._zero_bound

    @zero_bound.setter
    def zero_bound(self, zero_bound):
        """Sets the zero_bound of this QuestionsIdBody.

        Indicates if the student's score cannot be lower than zero  # noqa: E501

        :param zero_bound: The zero_bound of this QuestionsIdBody.  # noqa: E501
        :type: bool
        """

        self._zero_bound = zero_bound

    @property
    def objective_ids(self):
        """Gets the objective_ids of this QuestionsIdBody.  # noqa: E501


        :return: The objective_ids of this QuestionsIdBody.  # noqa: E501
        :rtype: list[int]
        """
        return self._objective_ids

    @objective_ids.setter
    def objective_ids(self, objective_ids):
        """Sets the objective_ids of this QuestionsIdBody.


        :param objective_ids: The objective_ids of this QuestionsIdBody.  # noqa: E501
        :type: list[int]
        """

        self._objective_ids = objective_ids

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(QuestionsIdBody, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, QuestionsIdBody):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
